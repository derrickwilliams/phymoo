{"version":3,"sources":["/Users/derwilliams/workspace/me/projects/phymoo/www/lib/angular-ui-router/src/resolve.js"],"names":[],"mappings":"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","file":"resolve-compiled.js","sourcesContent":["/**\n * @ngdoc object\n * @name ui.router.util.$resolve\n *\n * @requires $q\n * @requires $injector\n *\n * @description\n * Manages resolution of (acyclic) graphs of promises.\n */\n$Resolve.$inject = ['$q', '$injector'];\nfunction $Resolve(  $q,    $injector) {\n  \n  var VISIT_IN_PROGRESS = 1,\n      VISIT_DONE = 2,\n      NOTHING = {},\n      NO_DEPENDENCIES = [],\n      NO_LOCALS = NOTHING,\n      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n  \n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#study\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Studies a set of invocables that are likely to be used multiple times.\n   * <pre>\n   * $resolve.study(invocables)(locals, parent, self)\n   * </pre>\n   * is equivalent to\n   * <pre>\n   * $resolve.resolve(invocables, locals, parent, self)\n   * </pre>\n   * but the former is more efficient (in fact `resolve` just calls `study` \n   * internally).\n   *\n   * @param {object} invocables Invocable objects\n   * @return {function} a function to pass in locals, parent and self\n   */\n  this.study = function (invocables) {\n    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n    var invocableKeys = objectKeys(invocables || {});\n    \n    // Perform a topological sort of invocables to build an ordered plan\n    var plan = [], cycle = [], visited = {};\n    function visit(value, key) {\n      if (visited[key] === VISIT_DONE) return;\n      \n      cycle.push(key);\n      if (visited[key] === VISIT_IN_PROGRESS) {\n        cycle.splice(0, indexOf(cycle, key));\n        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n      }\n      visited[key] = VISIT_IN_PROGRESS;\n      \n      if (isString(value)) {\n        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n      } else {\n        var params = $injector.annotate(value);\n        forEach(params, function (param) {\n          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n        });\n        plan.push(key, value, params);\n      }\n      \n      cycle.pop();\n      visited[key] = VISIT_DONE;\n    }\n    forEach(invocables, visit);\n    invocables = cycle = visited = null; // plan is all that's required\n    \n    function isResolve(value) {\n      return isObject(value) && value.then && value.$$promises;\n    }\n    \n    return function (locals, parent, self) {\n      if (isResolve(locals) && self === undefined) {\n        self = parent; parent = locals; locals = null;\n      }\n      if (!locals) locals = NO_LOCALS;\n      else if (!isObject(locals)) {\n        throw new Error(\"'locals' must be an object\");\n      }       \n      if (!parent) parent = NO_PARENT;\n      else if (!isResolve(parent)) {\n        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n      }\n      \n      // To complete the overall resolution, we have to wait for the parent\n      // promise and for the promise for each invokable in our plan.\n      var resolution = $q.defer(),\n          result = resolution.promise,\n          promises = result.$$promises = {},\n          values = extend({}, locals),\n          wait = 1 + plan.length/3,\n          merged = false;\n          \n      function done() {\n        // Merge parent values we haven't got yet and publish our own $$values\n        if (!--wait) {\n          if (!merged) merge(values, parent.$$values); \n          result.$$values = values;\n          result.$$promises = result.$$promises || true; // keep for isResolve()\n          delete result.$$inheritedValues;\n          resolution.resolve(values);\n        }\n      }\n      \n      function fail(reason) {\n        result.$$failure = reason;\n        resolution.reject(reason);\n      }\n\n      // Short-circuit if parent has already failed\n      if (isDefined(parent.$$failure)) {\n        fail(parent.$$failure);\n        return result;\n      }\n      \n      if (parent.$$inheritedValues) {\n        merge(values, omit(parent.$$inheritedValues, invocableKeys));\n      }\n\n      // Merge parent values if the parent has already resolved, or merge\n      // parent promises and wait if the parent resolve is still in progress.\n      extend(promises, parent.$$promises);\n      if (parent.$$values) {\n        merged = merge(values, omit(parent.$$values, invocableKeys));\n        result.$$inheritedValues = omit(parent.$$values, invocableKeys);\n        done();\n      } else {\n        if (parent.$$inheritedValues) {\n          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);\n        }        \n        parent.then(done, fail);\n      }\n      \n      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n      for (var i=0, ii=plan.length; i<ii; i+=3) {\n        if (locals.hasOwnProperty(plan[i])) done();\n        else invoke(plan[i], plan[i+1], plan[i+2]);\n      }\n      \n      function invoke(key, invocable, params) {\n        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n        var invocation = $q.defer(), waitParams = 0;\n        function onfailure(reason) {\n          invocation.reject(reason);\n          fail(reason);\n        }\n        // Wait for any parameter that we have a promise for (either from parent or from this\n        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n        forEach(params, function (dep) {\n          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n            waitParams++;\n            promises[dep].then(function (result) {\n              values[dep] = result;\n              if (!(--waitParams)) proceed();\n            }, onfailure);\n          }\n        });\n        if (!waitParams) proceed();\n        function proceed() {\n          if (isDefined(result.$$failure)) return;\n          try {\n            invocation.resolve($injector.invoke(invocable, self, values));\n            invocation.promise.then(function (result) {\n              values[key] = result;\n              done();\n            }, onfailure);\n          } catch (e) {\n            onfailure(e);\n          }\n        }\n        // Publish promise synchronously; invocations further down in the plan may depend on it.\n        promises[key] = invocation.promise;\n      }\n      \n      return result;\n    };\n  };\n  \n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#resolve\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Resolves a set of invocables. An invocable is a function to be invoked via \n   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n   * An invocable can either return a value directly,\n   * or a `$q` promise. If a promise is returned it will be resolved and the \n   * resulting value will be used instead. Dependencies of invocables are resolved \n   * (in this order of precedence)\n   *\n   * - from the specified `locals`\n   * - from another invocable that is part of this `$resolve` call\n   * - from an invocable that is inherited from a `parent` call to `$resolve` \n   *   (or recursively\n   * - from any ancestor `$resolve` of that parent).\n   *\n   * The return value of `$resolve` is a promise for an object that contains \n   * (in this order of precedence)\n   *\n   * - any `locals` (if specified)\n   * - the resolved return values of all injectables\n   * - any values inherited from a `parent` call to `$resolve` (if specified)\n   *\n   * The promise will resolve after the `parent` promise (if any) and all promises \n   * returned by injectables have been resolved. If any invocable \n   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n   * same error. A rejection of a `parent` promise (if specified) will likewise be \n   * propagated immediately. Once the `$resolve` promise has been rejected, no \n   * further invocables will be called.\n   * \n   * Cyclic dependencies between invocables are not permitted and will caues `$resolve`\n   * to throw an error. As a special case, an injectable can depend on a parameter \n   * with the same name as the injectable, which will be fulfilled from the `parent` \n   * injectable of the same name. This allows inherited values to be decorated. \n   * Note that in this case any other injectable in the same `$resolve` with the same\n   * dependency would see the decorated value, not the inherited value.\n   *\n   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n   * exception.\n   *\n   * Invocables are invoked eagerly as soon as all dependencies are available. \n   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n   *\n   * As a special case, an invocable can be a string, in which case it is taken to \n   * be a service name to be passed to `$injector.get()`. This is supported primarily \n   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n   * routes.\n   *\n   * @param {object} invocables functions to invoke or \n   * `$injector` services to fetch.\n   * @param {object} locals  values to make available to the injectables\n   * @param {object} parent  a promise returned by another call to `$resolve`.\n   * @param {object} self  the `this` for the invoked methods\n   * @return {object} Promise for an object that contains the resolved return value\n   * of all invocables, as well as any inherited and local values.\n   */\n  this.resolve = function (invocables, locals, parent, self) {\n    return this.study(invocables)(locals, parent, self);\n  };\n}\n\nangular.module('ui.router.util').service('$resolve', $Resolve);\n\n"]}