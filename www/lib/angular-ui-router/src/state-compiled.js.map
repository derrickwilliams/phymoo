{"version":3,"sources":["/Users/derwilliams/workspace/me/projects/phymoo/www/lib/angular-ui-router/src/state.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAqBA,cAAc,CAAC,OAAO,GAAG,CAAC,oBAAoB,EAAE,4BAA4B,CAAC,CAAC;AAC9E,SAAS,cAAc,CAAI,kBAAkB,EAAI,kBAAkB,EAAE;;AAEnE,MAAI,IAAI;MAAE,MAAM,GAAG,EAAE;MAAE,MAAM;MAAE,KAAK,GAAG,EAAE;MAAE,WAAW,GAAG,UAAU,CAAC;;;AAGpE,MAAI,YAAY,GAAG;;;;;AAKjB,UAAM,EAAE,gBAAS,KAAK,EAAE;AACtB,UAAI,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,MAAM;AAAE,eAAO,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;OAAA;;AAG5E,UAAI,aAAa,GAAG,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;AACrD,aAAO,aAAa,GAAG,SAAS,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;KAC3D;;;AAGD,QAAI,EAAE,cAAS,KAAK,EAAE;AACpB,UAAI,KAAK,CAAC,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,IAAI,EAAE;AACrC,aAAK,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,GAAG,MAAM,CAAC,EAAE,EAAE,KAAK,CAAC,MAAM,CAAC,IAAI,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC;OAC1E;AACD,aAAO,KAAK,CAAC,IAAI,CAAC;KACnB;;;AAGD,OAAG;;;;;;;;;;OAAE,UAAS,KAAK,EAAE;AACnB,UAAI,GAAG,GAAG,KAAK,CAAC,GAAG;UAAE,MAAM,GAAG,EAAE,MAAM,EAAE,KAAK,CAAC,MAAM,IAAI,EAAE,EAAE,CAAC;;AAE7D,UAAI,QAAQ,CAAC,GAAG,CAAC,EAAE;AACjB,YAAI,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE,OAAO,kBAAkB,CAAC,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC;AACtF,eAAO,CAAC,KAAK,CAAC,MAAM,CAAC,SAAS,IAAI,IAAI,CAAA,CAAE,GAAG,CAAC,MAAM,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;OACjE;;AAED,UAAI,CAAC,GAAG,IAAI,kBAAkB,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,OAAO,GAAG,CAAC;AAC1D,YAAM,IAAI,KAAK,CAAC,eAAe,GAAG,GAAG,GAAG,cAAc,GAAG,KAAK,GAAG,GAAG,CAAC,CAAC;KACvE,CAAA;;;AAGD,aAAS,EAAE,mBAAS,KAAK,EAAE;AACzB,aAAO,KAAK,CAAC,GAAG,GAAG,KAAK,GAAI,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,SAAS,GAAG,IAAI,AAAC,CAAC;KAC3E;;;AAGD,aAAS,EAAE,mBAAS,KAAK,EAAE;AACzB,UAAI,MAAM,GAAG,KAAK,CAAC,GAAG,IAAI,KAAK,CAAC,GAAG,CAAC,MAAM,IAAI,IAAI,MAAM,CAAC,QAAQ,EAAE,CAAC;AACpE,aAAO,CAAC,KAAK,CAAC,MAAM,IAAI,EAAE,EAAE,UAAS,MAAM,EAAE,EAAE,EAAE;AAC/C,YAAI,CAAC,MAAM,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC,EAAE,CAAC,GAAG,IAAI,MAAM,CAAC,KAAK,CAAC,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,QAAQ,CAAC,CAAC;OAC5E,CAAC,CAAC;AACH,aAAO,MAAM,CAAC;KACf;;;AAGD,UAAM,EAAE,gBAAS,KAAK,EAAE;AACtB,aAAO,KAAK,CAAC,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,EAAE,EAAE,KAAK,CAAC,SAAS,CAAC,GAAG,IAAI,MAAM,CAAC,QAAQ,EAAE,CAAC;KAC3H;;;;;;;AAOD,SAAK;;;;;;;;;;OAAE,UAAS,KAAK,EAAE;AACrB,UAAI,KAAK,GAAG,EAAE,CAAC;;AAEf,aAAO,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,KAAK,GAAG,EAAE,EAAE,EAAE,KAAK,EAAE,EAAE,UAAU,IAAI,EAAE,IAAI,EAAE;AAClF,YAAI,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,IAAI,IAAI,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC;AAC3D,aAAK,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;OACpB,CAAC,CAAC;AACH,aAAO,KAAK,CAAC;KACd,CAAA;;;AAGD,QAAI,EAAE,cAAS,KAAK,EAAE;AACpB,aAAO,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;KAC5D;;;AAGD,YAAQ;;;;;;;;;;OAAE,UAAS,KAAK,EAAE;AACxB,UAAI,QAAQ,GAAG,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC,EAAE,EAAE,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC;AACrE,cAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;AAC5B,aAAO,QAAQ,CAAC;KACjB,CAAA;;AAED,cAAU,EAAE,EAAE;GACf,CAAC;;AAEF,WAAS,UAAU,CAAC,SAAS,EAAE;AAC7B,WAAO,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;GACrE;;AAED,WAAS,SAAS,CAAC,WAAW,EAAE,IAAI,EAAE;AACpC,QAAI,CAAC,WAAW;AAAE,aAAO,SAAS,CAAC;KAAA,AAEnC,IAAI,KAAK,GAAG,QAAQ,CAAC,WAAW,CAAC;QAC7B,IAAI,GAAI,KAAK,GAAG,WAAW,GAAG,WAAW,CAAC,IAAI;QAC9C,IAAI,GAAI,UAAU,CAAC,IAAI,CAAC,CAAC;;AAE7B,QAAI,IAAI,EAAE;AACR,UAAI,CAAC,IAAI,EAAE,MAAM,IAAI,KAAK,CAAC,qCAAqC,GAAI,IAAI,GAAG,GAAG,CAAC,CAAC;AAChF,UAAI,GAAG,SAAS,CAAC,IAAI,CAAC,CAAC;;AAEvB,UAAI,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;UAAE,CAAC,GAAG,CAAC;UAAE,UAAU,GAAG,GAAG,CAAC,MAAM;UAAE,OAAO,GAAG,IAAI,CAAC;;AAE1E,aAAO,CAAC,GAAG,UAAU,EAAE,CAAC,EAAE,EAAE;AAC1B,YAAI,GAAG,CAAC,CAAC,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,EAAE;AAC5B,iBAAO,GAAG,IAAI,CAAC;AACf,mBAAS;SACV;AACD,YAAI,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;AAClB,cAAI,CAAC,OAAO,CAAC,MAAM,EAAE,MAAM,IAAI,KAAK,CAAC,QAAQ,GAAG,IAAI,GAAG,yBAAyB,GAAG,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC,CAAC;AACpG,iBAAO,GAAG,OAAO,CAAC,MAAM,CAAC;AACzB,mBAAS;SACV;AACD,cAAM;OACP;AACD,SAAG,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAC7B,UAAI,GAAG,OAAO,CAAC,IAAI,IAAI,OAAO,CAAC,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,EAAE,CAAA,AAAC,GAAG,GAAG,CAAC;KAC9D;AACD,QAAI,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;;AAEzB,QAAI,KAAK,KAAK,KAAK,IAAK,CAAC,KAAK,KAAK,KAAK,KAAK,WAAW,IAAI,KAAK,CAAC,IAAI,KAAK,WAAW,CAAA,AAAC,CAAC,AAAC,EAAE;AACzF,aAAO,KAAK,CAAC;KACd;AACD,WAAO,SAAS,CAAC;GAClB;;AAED,WAAS,UAAU,CAAC,UAAU,EAAE,KAAK,EAAE;AACrC,QAAI,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE;AACtB,WAAK,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC;KACxB;AACD,SAAK,CAAC,UAAU,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;GAC/B;;AAED,WAAS,mBAAmB,CAAC,UAAU,EAAE;AACvC,QAAI,MAAM,GAAG,KAAK,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC;AACrC,WAAM,MAAM,CAAC,MAAM,EAAE;AACnB,mBAAa,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC;KAC/B;GACF;;AAED,WAAS,aAAa,CAAC,KAAK,EAAE;;AAE5B,SAAK,GAAG,OAAO,CAAC,KAAK,EAAE;AACrB,UAAI,EAAE,KAAK;AACX,aAAO,EAAE,KAAK,CAAC,OAAO,IAAI,EAAE;AAC5B,cAAQ,EAAE,oBAAW;AAAE,eAAO,IAAI,CAAC,IAAI,CAAC;OAAE;KAC3C,CAAC,CAAC;;AAEH,QAAI,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC;AACtB,QAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;AAC/F,QAAI,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,SAAS,GAAG,IAAI,GAAG,uBAAuB,CAAC,CAAC;;;AAG7F,QAAI,UAAU,GAAG,AAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,GAAI,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAChF,AAAC,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC,GAAI,KAAK,CAAC,MAAM,GACvC,AAAC,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,GAAI,KAAK,CAAC,MAAM,CAAC,IAAI,GAC3E,EAAE,CAAC;;;AAGT,QAAI,UAAU,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,EAAE;AACrC,aAAO,UAAU,CAAC,UAAU,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC;KAC3C;;AAED,SAAK,IAAI,GAAG,IAAI,YAAY,EAAE;AAC5B,UAAI,UAAU,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,EAAE,KAAK,CAAC,GAAG,CAAC,GAAG,YAAY,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,YAAY,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC;KACxG;AACD,UAAM,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC;;;AAGrB,QAAI,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,KAAK,CAAC,GAAG,EAAE;AACpC,wBAAkB,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,QAAQ,EAAE,cAAc,EAAE,UAAU,MAAM,EAAE,YAAY,EAAE;AAC5F,YAAI,MAAM,CAAC,QAAQ,CAAC,SAAS,IAAI,KAAK,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,YAAY,CAAC,EAAE;AAC7E,gBAAM,CAAC,YAAY,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,CAAC,CAAC;SACxE;OACF,CAAC,CAAC,CAAC;KACL;;;AAGD,uBAAmB,CAAC,IAAI,CAAC,CAAC;;AAE1B,WAAO,KAAK,CAAC;GACd;;;AAGD,WAAS,MAAM,CAAE,IAAI,EAAE;AACrB,WAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;GAC/B;;;AAGD,WAAS,kBAAkB,CAAE,IAAI,EAAE;AACjC,QAAI,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;QAC9B,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;;;AAG/C,QAAI,YAAY,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;AAC3B,cAAQ,GAAG,QAAQ,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,EAAE,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9D,cAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KACzB;;AAED,QAAI,YAAY,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,IAAI,EAAE;AACjD,cAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,EAAE,YAAY,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,MAAM,CAAC,SAAS,CAAC,CAAC;AAChG,cAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;KACtB;;AAED,QAAI,YAAY,CAAC,MAAM,IAAI,QAAQ,CAAC,MAAM,EAAE;AAC1C,aAAO,KAAK,CAAC;KACd;;;AAGD,SAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;AACnD,UAAI,YAAY,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;AAC3B,gBAAQ,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;OACnB;KACF;;AAED,WAAO,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,YAAY,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;GACpD;;;AAID,MAAI,GAAG,aAAa,CAAC;AACnB,QAAI,EAAE,EAAE;AACR,OAAG,EAAE,GAAG;AACR,SAAK,EAAE,IAAI;AACX,cAAY,IAAI;GACjB,CAAC,CAAC;AACH,MAAI,CAAC,SAAS,GAAG,IAAI,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8FtB,MAAI,CAAC,SAAS,GAAG,SAAS,CAAC;AAC3B,WAAS,SAAS,CAAC,IAAI,EAAE,IAAI,EAAE;;AAE7B,QAAI,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE;AACtC,aAAO,YAAY,CAAC,IAAI,CAAC,CAAC;KAC3B;AACD,QAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;AACxC,aAAO,IAAI,CAAC;KACb;AACD,QAAI,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;AACxD,kBAAY,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC;KACpD;AACD,gBAAY,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;AAC1B,WAAO,IAAI,CAAC;GACb;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsTD,MAAI,CAAC,KAAK,GAAG,KAAK,CAAC;AACnB,WAAS,KAAK,CAAC,IAAI,EAAE,UAAU,EAAE;;AAE/B,QAAI,QAAQ,CAAC,IAAI,CAAC,EAAE,UAAU,GAAG,IAAI,CAAC,KACjC,UAAU,CAAC,IAAI,GAAG,IAAI,CAAC;AAC5B,iBAAa,CAAC,UAAU,CAAC,CAAC;AAC1B,WAAO,IAAI,CAAC;GACb;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BD,MAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACjB,MAAI,CAAC,OAAO,GAAG,CAAC,YAAY,EAAE,IAAI,EAAE,OAAO,EAAE,WAAW,EAAE,UAAU,EAAE,cAAc,EAAE,YAAY,EAAE,WAAW,EAAE,oBAAoB,CAAC,CAAC;AACvI,WAAS,IAAI,CAAI,UAAU,EAAI,EAAE,EAAI,KAAK,EAAI,SAAS,EAAI,QAAQ,EAAI,YAAY,EAAI,UAAU,EAAI,SAAS,EAAI,kBAAkB,EAAE;;AAEpI,QAAI,oBAAoB,GAAG,EAAE,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC,CAAC;AACzE,QAAI,mBAAmB,GAAG,EAAE,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,sBAAsB,CAAC,CAAC,CAAC;AACvE,QAAI,iBAAiB,GAAG,EAAE,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,oBAAoB,CAAC,CAAC,CAAC;AACnE,QAAI,gBAAgB,GAAG,EAAE,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAAC,CAAC;;;;AAIjE,aAAS,cAAc,CAAC,QAAQ,EAAE,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCxD,UAAI,GAAG,GAAG,UAAU,CAAC,UAAU,CAAC,gBAAgB,EAAE,QAAQ,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;;AAE3E,UAAI,GAAG,CAAC,gBAAgB,EAAE;AACxB,kBAAU,CAAC,MAAM,EAAE,CAAC;AACpB,eAAO,iBAAiB,CAAC;OAC1B;;AAED,UAAI,CAAC,GAAG,CAAC,KAAK,EAAE;AACd,eAAO,IAAI,CAAC;OACb;;;AAGD,UAAI,OAAO,CAAC,MAAM,EAAE;AAClB,kBAAU,CAAC,MAAM,EAAE,CAAC;AACpB,eAAO,gBAAgB,CAAC;OACzB;AACD,UAAI,eAAe,GAAG,MAAM,CAAC,UAAU,GAAG,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;;AAE7D,qBAAe,CAAC,IAAI,CAAC,YAAW;AAC9B,YAAI,eAAe,KAAK,MAAM,CAAC,UAAU,EAAE,OAAO,oBAAoB,CAAC;AACvE,gBAAQ,CAAC,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC;AAC/B,eAAO,MAAM,CAAC,YAAY,CAAC,QAAQ,CAAC,EAAE,EAAE,QAAQ,CAAC,QAAQ,EAAE,QAAQ,CAAC,OAAO,CAAC,CAAC;OAC9E,EAAE,YAAW;AACZ,eAAO,iBAAiB,CAAC;OAC1B,CAAC,CAAC;AACH,gBAAU,CAAC,MAAM,EAAE,CAAC;;AAEpB,aAAO,eAAe,CAAC;KACxB;;AAED,QAAI,CAAC,MAAM,GAAG,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,EAAE,YAAY,EAAE,EAAE,EAAE,EAAE,CAAC;;AAE/D,UAAM,GAAG;AACP,YAAM,EAAE,EAAE;AACV,aAAO,EAAE,IAAI,CAAC,IAAI;AAClB,cAAQ,EAAE,IAAI;AACd,gBAAU,EAAE,IAAI;KACjB,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCF,UAAM,CAAC,MAAM,GAAG,SAAS,MAAM,GAAG;AAChC,aAAO,MAAM,CAAC,YAAY,CAAC,MAAM,CAAC,OAAO,EAAE,YAAY,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC;KAC1G,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoEF,UAAM,CAAC,EAAE,GAAG,SAAS,EAAE,CAAC,EAAE,EAAE,MAAM,EAAE,OAAO,EAAE;AAC3C,aAAO,MAAM,CAAC,YAAY,CAAC,EAAE,EAAE,MAAM,EAAE,MAAM,CAAC,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,EAAE,MAAM,CAAC,QAAQ,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC;KACvG,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwCF,UAAM,CAAC,YAAY,GAAG,SAAS,YAAY,CAAC,EAAE,EAAE,QAAQ,EAAE,OAAO,EAAE;AACjE,cAAQ,GAAG,QAAQ,IAAI,EAAE,CAAC;AAC1B,aAAO,GAAG,MAAM,CAAC;AACf,gBAAQ,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,QAAQ,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,KAAK;OAC3F,EAAE,OAAO,IAAI,EAAE,CAAC,CAAC;;AAElB,UAAI,IAAI,GAAG,MAAM,CAAC,QAAQ;UAAE,UAAU,GAAG,MAAM,CAAC,MAAM;UAAE,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC;AAC7E,UAAI,GAAG;UAAE,OAAO,GAAG,SAAS,CAAC,EAAE,EAAE,OAAO,CAAC,QAAQ,CAAC,CAAC;;AAEnD,UAAI,CAAC,SAAS,CAAC,OAAO,CAAC,EAAE;AACvB,YAAI,QAAQ,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,QAAQ,EAAE,QAAQ,EAAE,OAAO,EAAE,OAAO,EAAE,CAAC;AAChE,YAAI,cAAc,GAAG,cAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,IAAI,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC;;AAE9E,YAAI,cAAc,EAAE;AAClB,iBAAO,cAAc,CAAC;SACvB;;;;AAID,UAAE,GAAG,QAAQ,CAAC,EAAE,CAAC;AACjB,gBAAQ,GAAG,QAAQ,CAAC,QAAQ,CAAC;AAC7B,eAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;AAC3B,eAAO,GAAG,SAAS,CAAC,EAAE,EAAE,OAAO,CAAC,QAAQ,CAAC,CAAC;;AAE1C,YAAI,CAAC,SAAS,CAAC,OAAO,CAAC,EAAE;AACvB,cAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,MAAM,IAAI,KAAK,CAAC,iBAAiB,GAAG,EAAE,GAAG,GAAG,CAAC,CAAC;AACrE,gBAAM,IAAI,KAAK,CAAC,qBAAqB,GAAG,EAAE,GAAG,gBAAgB,GAAG,OAAO,CAAC,QAAQ,GAAG,GAAG,CAAC,CAAC;SACzF;OACF;AACD,UAAI,OAAO,CAAC,WAAW,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,uCAAuC,GAAG,EAAE,GAAG,GAAG,CAAC,CAAC;AAC9F,UAAI,OAAO,CAAC,OAAO,EAAE,QAAQ,GAAG,aAAa,CAAC,YAAY,EAAE,QAAQ,IAAI,EAAE,EAAE,MAAM,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;AACtG,UAAI,CAAC,OAAO,CAAC,MAAM,CAAC,WAAW,CAAC,QAAQ,CAAC;AAAE,eAAO,gBAAgB,CAAC;OAAA,AAEnE,QAAQ,GAAG,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;AAC7C,QAAE,GAAG,OAAO,CAAC;;AAEb,UAAI,MAAM,GAAG,EAAE,CAAC,IAAI,CAAC;;;AAGrB,UAAI,IAAI,GAAG,CAAC;UAAE,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC;UAAE,MAAM,GAAG,IAAI,CAAC,MAAM;UAAE,QAAQ,GAAG,EAAE,CAAC;;AAExE,UAAI,CAAC,OAAO,CAAC,MAAM,EAAE;AACnB,eAAO,KAAK,IAAI,KAAK,KAAK,QAAQ,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC,SAAS,CAAC,QAAQ,CAAC,QAAQ,EAAE,UAAU,CAAC,EAAE;AAC1F,gBAAM,GAAG,QAAQ,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC;AACvC,cAAI,EAAE,CAAC;AACP,eAAK,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;SACtB;OACF;;;;;;;AAOD,UAAI,mBAAmB,CAAC,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,CAAC,EAAE;AAClD,YAAI,EAAE,CAAC,IAAI,CAAC,cAAc,KAAK,KAAK,EAAE,UAAU,CAAC,MAAM,EAAE,CAAC;AAC1D,cAAM,CAAC,UAAU,GAAG,IAAI,CAAC;AACzB,eAAO,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;OAChC;;;AAGD,cAAQ,GAAG,YAAY,CAAC,EAAE,CAAC,MAAM,CAAC,MAAM,EAAE,EAAE,QAAQ,IAAI,EAAE,CAAC,CAAC;;;AAG5D,UAAI,OAAO,CAAC,MAAM,EAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BlB,YAAI,UAAU,CAAC,UAAU,CAAC,mBAAmB,EAAE,EAAE,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC,gBAAgB,EAAE;AACzG,oBAAU,CAAC,MAAM,EAAE,CAAC;AACpB,iBAAO,mBAAmB,CAAC;SAC5B;OACF;;;;;;;;;AASD,UAAI,QAAQ,GAAG,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;;AAE/B,WAAK,IAAI,CAAC,GAAG,IAAI,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,EAAE;AAC5D,cAAM,GAAG,QAAQ,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC;AACvC,gBAAQ,GAAG,YAAY,CAAC,KAAK,EAAE,QAAQ,EAAE,KAAK,KAAK,EAAE,EAAE,QAAQ,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;OACnF;;;;;;AAMD,UAAI,UAAU,GAAG,MAAM,CAAC,UAAU,GAAG,QAAQ,CAAC,IAAI,CAAC,YAAY;AAC7D,YAAI,CAAC,EAAE,QAAQ,EAAE,OAAO,CAAC;;AAEzB,YAAI,MAAM,CAAC,UAAU,KAAK,UAAU,EAAE,OAAO,oBAAoB,CAAC;;;AAGlE,aAAK,CAAC,GAAG,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,IAAI,EAAE,CAAC,EAAE,EAAE;AAC5C,iBAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;AACtB,cAAI,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE;AACvB,qBAAS,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;WAC7E;AACD,iBAAO,CAAC,MAAM,GAAG,IAAI,CAAC;SACvB;;;AAGD,aAAK,CAAC,GAAG,IAAI,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACrC,kBAAQ,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;AACrB,kBAAQ,CAAC,MAAM,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;AAC9B,cAAI,QAAQ,CAAC,IAAI,CAAC,OAAO,EAAE;AACzB,qBAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,EAAE,QAAQ,CAAC,IAAI,EAAE,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;WACjF;SACF;;;AAGD,YAAI,MAAM,CAAC,UAAU,KAAK,UAAU,EAAE,OAAO,oBAAoB,CAAC;;;AAGlE,cAAM,CAAC,QAAQ,GAAG,EAAE,CAAC;AACrB,cAAM,CAAC,OAAO,GAAG,EAAE,CAAC,IAAI,CAAC;AACzB,cAAM,CAAC,MAAM,GAAG,QAAQ,CAAC;AACzB,YAAI,CAAC,MAAM,CAAC,MAAM,EAAE,YAAY,CAAC,CAAC;AAClC,cAAM,CAAC,UAAU,GAAG,IAAI,CAAC;;AAEzB,YAAI,OAAO,CAAC,QAAQ,IAAI,EAAE,CAAC,SAAS,EAAE;AACpC,oBAAU,CAAC,IAAI,CAAC,EAAE,CAAC,SAAS,CAAC,GAAG,EAAE,EAAE,CAAC,SAAS,CAAC,MAAM,CAAC,OAAO,CAAC,YAAY,EAAE;AAC1E,yBAAa,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,CAAC,QAAQ,KAAK,SAAS;WAC7D,CAAC,CAAC;SACJ;;AAED,YAAI,OAAO,CAAC,MAAM,EAAE;;;;;;;;;;;;;;;AAelB,oBAAU,CAAC,UAAU,CAAC,qBAAqB,EAAE,EAAE,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;SACxF;AACD,kBAAU,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;;AAExB,eAAO,MAAM,CAAC,OAAO,CAAC;OACvB,EAAE,UAAU,KAAK,EAAE;AAClB,YAAI,MAAM,CAAC,UAAU,KAAK,UAAU,EAAE,OAAO,oBAAoB,CAAC;;AAElE,cAAM,CAAC,UAAU,GAAG,IAAI,CAAC;;;;;;;;;;;;;;;;;;;AAmBzB,WAAG,GAAG,UAAU,CAAC,UAAU,CAAC,mBAAmB,EAAE,EAAE,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,CAAC,IAAI,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC;;AAElG,YAAI,CAAC,GAAG,CAAC,gBAAgB,EAAE;AACvB,oBAAU,CAAC,MAAM,EAAE,CAAC;SACvB;;AAED,eAAO,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;OACzB,CAAC,CAAC;;AAEH,aAAO,UAAU,CAAC;KACnB,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCF,UAAM,CAAC,EAAE,GAAG,SAAS,EAAE,CAAC,WAAW,EAAE,MAAM,EAAE,OAAO,EAAE;AACpD,aAAO,GAAG,MAAM,CAAC,EAAE,QAAQ,EAAE,MAAM,CAAC,QAAQ,EAAE,EAAE,OAAO,IAAI,EAAE,CAAC,CAAC;AAC/D,UAAI,KAAK,GAAG,SAAS,CAAC,WAAW,EAAE,OAAO,CAAC,QAAQ,CAAC,CAAC;;AAErD,UAAI,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE;AAAE,eAAO,SAAS,CAAC;OAAE;AAC5C,UAAI,MAAM,CAAC,QAAQ,KAAK,KAAK,EAAE;AAAE,eAAO,KAAK,CAAC;OAAE;AAChD,aAAO,MAAM,GAAG,YAAY,CAAC,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,YAAY,CAAC,GAAG,IAAI,CAAC;KAClF,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqDF,UAAM,CAAC,QAAQ,GAAG,SAAS,QAAQ,CAAC,WAAW,EAAE,MAAM,EAAE,OAAO,EAAE;AAChE,aAAO,GAAG,MAAM,CAAC,EAAE,QAAQ,EAAE,MAAM,CAAC,QAAQ,EAAE,EAAE,OAAO,IAAI,EAAE,CAAC,CAAC;AAC/D,UAAI,QAAQ,CAAC,WAAW,CAAC,IAAI,MAAM,CAAC,WAAW,CAAC,EAAE;AAChD,YAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,EAAE;AACpC,iBAAO,KAAK,CAAC;SACd;AACD,mBAAW,GAAG,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC;OACpC;;AAED,UAAI,KAAK,GAAG,SAAS,CAAC,WAAW,EAAE,OAAO,CAAC,QAAQ,CAAC,CAAC;AACrD,UAAI,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE;AAAE,eAAO,SAAS,CAAC;OAAE;AAC5C,UAAI,CAAC,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,EAAE;AAAE,eAAO,KAAK,CAAC;OAAE;AACvE,aAAO,MAAM,GAAG,YAAY,CAAC,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,YAAY,EAAE,UAAU,CAAC,MAAM,CAAC,CAAC,GAAG,IAAI,CAAC;KACtG,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BF,UAAM,CAAC,IAAI,GAAG,SAAS,IAAI,CAAC,WAAW,EAAE,MAAM,EAAE,OAAO,EAAE;AACxD,aAAO,GAAG,MAAM,CAAC;AACf,aAAK,EAAK,IAAI;AACd,eAAO,EAAG,IAAI;AACd,gBAAQ,EAAE,KAAK;AACf,gBAAQ,EAAE,MAAM,CAAC,QAAQ;OAC1B,EAAE,OAAO,IAAI,EAAE,CAAC,CAAC;;AAElB,UAAI,KAAK,GAAG,SAAS,CAAC,WAAW,EAAE,OAAO,CAAC,QAAQ,CAAC,CAAC;;AAErD,UAAI,CAAC,SAAS,CAAC,KAAK,CAAC;AAAE,eAAO,IAAI,CAAC;OAAA,AACnC,IAAI,OAAO,CAAC,OAAO,EAAE,MAAM,GAAG,aAAa,CAAC,YAAY,EAAE,MAAM,IAAI,EAAE,EAAE,MAAM,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;;AAEhG,UAAI,GAAG,GAAG,AAAC,KAAK,IAAI,OAAO,CAAC,KAAK,GAAI,KAAK,CAAC,SAAS,GAAG,KAAK,CAAC;;AAE7D,UAAI,CAAC,GAAG,IAAI,GAAG,CAAC,GAAG,KAAK,SAAS,IAAI,GAAG,CAAC,GAAG,KAAK,IAAI,EAAE;AACrD,eAAO,IAAI,CAAC;OACb;AACD,aAAO,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,YAAY,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,EAAE,EAAE,MAAM,IAAI,EAAE,CAAC,EAAE;AACjF,gBAAQ,EAAE,OAAO,CAAC,QAAQ;OAC3B,CAAC,CAAC;KACJ,CAAC;;;;;;;;;;;;;;;AAeF,UAAM,CAAC,GAAG,GAAG,UAAU,WAAW,EAAE,OAAO,EAAE;AAC3C,UAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE,OAAO,GAAG,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE,UAAS,IAAI,EAAE;AAAE,eAAO,MAAM,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC;OAAE,CAAC,CAAC;AACzG,UAAI,KAAK,GAAG,SAAS,CAAC,WAAW,EAAE,OAAO,IAAI,MAAM,CAAC,QAAQ,CAAC,CAAC;AAC/D,aAAO,AAAC,KAAK,IAAI,KAAK,CAAC,IAAI,GAAI,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC;KAClD,CAAC;;AAEF,aAAS,YAAY,CAAC,KAAK,EAAE,MAAM,EAAE,iBAAiB,EAAE,SAAS,EAAE,GAAG,EAAE,OAAO,EAAE;;;;;AAK/E,UAAI,YAAY,GAAG,AAAC,iBAAiB,GAAI,MAAM,GAAG,YAAY,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,EAAE,EAAE,MAAM,CAAC,CAAC;AAC9F,UAAI,MAAM,GAAG,EAAE,YAAY,EAAE,YAAY,EAAE,CAAC;;;;;;AAM5C,SAAG,CAAC,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,EAAE,MAAM,EAAE,GAAG,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;AAC1E,UAAI,QAAQ,GAAG,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,OAAO,EAAE;AAClD,WAAG,CAAC,OAAO,GAAG,OAAO,CAAC;OACvB,CAAC,CAAC,CAAC;AACJ,UAAI,SAAS,EAAE,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;;;AAGxC,aAAO,CAAC,KAAK,CAAC,KAAK,EAAE,UAAU,IAAI,EAAE,IAAI,EAAE;AACzC,YAAI,WAAW,GAAI,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,OAAO,KAAK,KAAK,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,GAAG,EAAE,AAAC,CAAC;AACvF,mBAAW,CAAC,SAAS,GAAG,CAAE,YAAY;AACpC,iBAAO,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,YAAY,EAAE,MAAM,EAAE,OAAO,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC;SAC7G,CAAC,CAAC;;AAEH,gBAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,WAAW,EAAE,MAAM,EAAE,GAAG,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,IAAI,CAAC,UAAU,MAAM,EAAE;;AAE7F,cAAI,UAAU,CAAC,IAAI,CAAC,kBAAkB,CAAC,IAAI,OAAO,CAAC,IAAI,CAAC,kBAAkB,CAAC,EAAE;AAC3E,gBAAI,YAAY,GAAG,OAAO,CAAC,MAAM,CAAC,EAAE,EAAE,WAAW,EAAE,MAAM,CAAC,CAAC;AAC3D,kBAAM,CAAC,YAAY,GAAG,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,kBAAkB,EAAE,IAAI,EAAE,YAAY,CAAC,CAAC;WACrF,MAAM;AACL,kBAAM,CAAC,YAAY,GAAG,IAAI,CAAC,UAAU,CAAC;WACvC;;AAED,gBAAM,CAAC,OAAO,GAAG,KAAK,CAAC;AACvB,gBAAM,CAAC,cAAc,GAAG,IAAI,CAAC,YAAY,CAAC;AAC1C,aAAG,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;SACpB,CAAC,CAAC,CAAC;OACL,CAAC,CAAC;;;AAGH,aAAO,EAAE,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,UAAU,MAAM,EAAE;AAC7C,eAAO,GAAG,CAAC;OACZ,CAAC,CAAC;KACJ;;AAED,WAAO,MAAM,CAAC;GACf;;AAED,WAAS,mBAAmB,CAAC,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE;AACtD,QAAI,EAAE,KAAK,IAAI,KAAK,AAAC,MAAM,KAAK,IAAI,CAAC,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,IAAM,EAAE,CAAC,IAAI,CAAC,cAAc,KAAK,KAAK,CAAC,AAAC,EAAE;AACtG,aAAO,IAAI,CAAC;KACb;GACF;CACF;;AAED,OAAO,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAC9B,KAAK,CAAC,cAAc,EAAE,EAAE,CAAC,CACzB,QAAQ,CAAC,QAAQ,EAAE,cAAc,CAAC,CAAC","file":"state-compiled.js","sourcesContent":["/**\n * @ngdoc object\n * @name ui.router.state.$stateProvider\n *\n * @requires ui.router.router.$urlRouterProvider\n * @requires ui.router.util.$urlMatcherFactoryProvider\n *\n * @description\n * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n * on state.\n *\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\n * navigation. A state describes (via the controller / template / view properties) what\n * the UI looks like and does at that place.\n *\n * States often have things in common, and the primary way of factoring out these\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n * nested states.\n *\n * The `$stateProvider` provides interfaces to declare these states for your app.\n */\n$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\nfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\n  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\n  // Builds state properties from definition passed to registerState()\n  var stateBuilder = {\n\n    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n    // state.children = [];\n    // if (parent) parent.children.push(state);\n    parent: function(state) {\n      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n      // regex matches any valid composite state name\n      // would match \"contact.list\" but not \"contacts\"\n      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n      return compositeName ? findState(compositeName[1]) : root;\n    },\n\n    // inherit 'data' from parent and override by own values (if any)\n    data: function(state) {\n      if (state.parent && state.parent.data) {\n        state.data = state.self.data = extend({}, state.parent.data, state.data);\n      }\n      return state.data;\n    },\n\n    // Build a URLMatcher if necessary, either via a relative or absolute URL\n    url: function(state) {\n      var url = state.url, config = { params: state.params || {} };\n\n      if (isString(url)) {\n        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n        return (state.parent.navigable || root).url.concat(url, config);\n      }\n\n      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n    },\n\n    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n    navigable: function(state) {\n      return state.url ? state : (state.parent ? state.parent.navigable : null);\n    },\n\n    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params\n    ownParams: function(state) {\n      var params = state.url && state.url.params || new $$UMFP.ParamSet();\n      forEach(state.params || {}, function(config, id) {\n        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, \"config\");\n      });\n      return params;\n    },\n\n    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n    params: function(state) {\n      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), state.ownParams) : new $$UMFP.ParamSet();\n    },\n\n    // If there is no explicit multi-view configuration, make one up so we don't have\n    // to handle both cases in the view directive later. Note that having an explicit\n    // 'views' property will mean the default unnamed view properties are ignored. This\n    // is also a good time to resolve view names to absolute names, so everything is a\n    // straight lookup at link time.\n    views: function(state) {\n      var views = {};\n\n      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n        views[name] = view;\n      });\n      return views;\n    },\n\n    // Keep a full path from the root down to this state as this is needed for state activation.\n    path: function(state) {\n      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n    },\n\n    // Speed up $state.contains() as it's used a lot\n    includes: function(state) {\n      var includes = state.parent ? extend({}, state.parent.includes) : {};\n      includes[state.name] = true;\n      return includes;\n    },\n\n    $delegates: {}\n  };\n\n  function isRelative(stateName) {\n    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n  }\n\n  function findState(stateOrName, base) {\n    if (!stateOrName) return undefined;\n\n    var isStr = isString(stateOrName),\n        name  = isStr ? stateOrName : stateOrName.name,\n        path  = isRelative(name);\n\n    if (path) {\n      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n      base = findState(base);\n      \n      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\n      for (; i < pathLength; i++) {\n        if (rel[i] === \"\" && i === 0) {\n          current = base;\n          continue;\n        }\n        if (rel[i] === \"^\") {\n          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n          current = current.parent;\n          continue;\n        }\n        break;\n      }\n      rel = rel.slice(i).join(\".\");\n      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n    }\n    var state = states[name];\n\n    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n      return state;\n    }\n    return undefined;\n  }\n\n  function queueState(parentName, state) {\n    if (!queue[parentName]) {\n      queue[parentName] = [];\n    }\n    queue[parentName].push(state);\n  }\n\n  function flushQueuedChildren(parentName) {\n    var queued = queue[parentName] || [];\n    while(queued.length) {\n      registerState(queued.shift());\n    }\n  }\n\n  function registerState(state) {\n    // Wrap a new object around the state so we can store our private details easily.\n    state = inherit(state, {\n      self: state,\n      resolve: state.resolve || {},\n      toString: function() { return this.name; }\n    });\n\n    var name = state.name;\n    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"'' is already defined\");\n\n    // Get parent name\n    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n        : (isString(state.parent)) ? state.parent\n        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name\n        : '';\n\n    // If parent is not registered yet, add state to queue and register later\n    if (parentName && !states[parentName]) {\n      return queueState(parentName, state.self);\n    }\n\n    for (var key in stateBuilder) {\n      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n    }\n    states[name] = state;\n\n    // Register the state in the global state list and with $urlRouter if necessary.\n    if (!state[abstractKey] && state.url) {\n      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n          $state.transitionTo(state, $match, { inherit: true, location: false });\n        }\n      }]);\n    }\n\n    // Register any queued children\n    flushQueuedChildren(name);\n\n    return state;\n  }\n\n  // Checks text to see if it looks like a glob.\n  function isGlob (text) {\n    return text.indexOf('*') > -1;\n  }\n\n  // Returns true if glob matches current $state name.\n  function doesStateMatchGlob (glob) {\n    var globSegments = glob.split('.'),\n        segments = $state.$current.name.split('.');\n\n    //match greedy starts\n    if (globSegments[0] === '**') {\n       segments = segments.slice(indexOf(segments, globSegments[1]));\n       segments.unshift('**');\n    }\n    //match greedy ends\n    if (globSegments[globSegments.length - 1] === '**') {\n       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n       segments.push('**');\n    }\n\n    if (globSegments.length != segments.length) {\n      return false;\n    }\n\n    //match single stars\n    for (var i = 0, l = globSegments.length; i < l; i++) {\n      if (globSegments[i] === '*') {\n        segments[i] = '*';\n      }\n    }\n\n    return segments.join('') === globSegments.join('');\n  }\n\n\n  // Implicit root state that is always active\n  root = registerState({\n    name: '',\n    url: '^',\n    views: null,\n    'abstract': true\n  });\n  root.navigable = null;\n\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#decorator\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Allows you to extend (carefully) or override (at your own peril) the \n   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n   * to add custom functionality to ui-router, for example inferring templateUrl \n   * based on the state name.\n   *\n   * When passing only a name, it returns the current (original or decorated) builder\n   * function that matches `name`.\n   *\n   * The builder functions that can be decorated are listed below. Though not all\n   * necessarily have a good use case for decoration, that is up to you to decide.\n   *\n   * In addition, users can attach custom decorators, which will generate new \n   * properties within the state's internal definition. There is currently no clear \n   * use-case for this beyond accessing internal states (i.e. $state.$current), \n   * however, expect this to become increasingly relevant as we introduce additional \n   * meta-programming features.\n   *\n   * **Warning**: Decorators should not be interdependent because the order of \n   * execution of the builder functions in non-deterministic. Builder functions \n   * should only be dependent on the state definition object and super function.\n   *\n   *\n   * Existing builder functions and current return values:\n   *\n   * - **parent** `{object}` - returns the parent state object.\n   * - **data** `{object}` - returns state data, including any inherited data that is not\n   *   overridden by own values (if any).\n   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n   *   or `null`.\n   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n   *   navigable).\n   * - **params** `{object}` - returns an array of state params that are ensured to \n   *   be a super-set of parent's params.\n   * - **views** `{object}` - returns a views object where each key is an absolute view \n   *   name (i.e. \"viewName@stateName\") and each value is the config object \n   *   (template, controller) for the view. Even when you don't use the views object \n   *   explicitly on a state config, one is still created for you internally.\n   *   So by decorating this builder function you have access to decorating template \n   *   and controller properties.\n   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n   *   not including any params defined by ancestor states.\n   * - **path** `{string}` - returns the full path from the root down to this state. \n   *   Needed for state activation.\n   * - **includes** `{object}` - returns an object that includes every state that \n   *   would pass a `$state.includes()` test.\n   *\n   * @example\n   * <pre>\n   * // Override the internal 'views' builder with a function that takes the state\n   * // definition, and a reference to the internal function being overridden:\n   * $stateProvider.decorator('views', function (state, parent) {\n   *   var result = {},\n   *       views = parent(state);\n   *\n   *   angular.forEach(views, function (config, name) {\n   *     var autoName = (state.name + '.' + name).replace('.', '/');\n   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n   *     result[name] = config;\n   *   });\n   *   return result;\n   * });\n   *\n   * $stateProvider.state('home', {\n   *   views: {\n   *     'contact.list': { controller: 'ListController' },\n   *     'contact.item': { controller: 'ItemController' }\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * $state.go('home');\n   * // Auto-populates list and item views with /partials/home/contact/list.html,\n   * // and /partials/home/contact/item.html, respectively.\n   * </pre>\n   *\n   * @param {string} name The name of the builder function to decorate. \n   * @param {object} func A function that is responsible for decorating the original \n   * builder function. The function receives two parameters:\n   *\n   *   - `{object}` - state - The state config object.\n   *   - `{object}` - super - The original builder function.\n   *\n   * @return {object} $stateProvider - $stateProvider instance\n   */\n  this.decorator = decorator;\n  function decorator(name, func) {\n    /*jshint validthis: true */\n    if (isString(name) && !isDefined(func)) {\n      return stateBuilder[name];\n    }\n    if (!isFunction(func) || !isString(name)) {\n      return this;\n    }\n    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n      stateBuilder.$delegates[name] = stateBuilder[name];\n    }\n    stateBuilder[name] = func;\n    return this;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#state\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Registers a state configuration under a given state name. The stateConfig object\n   * has the following acceptable properties.\n   *\n   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n   * @param {object} stateConfig State configuration object.\n   * @param {string|function=} stateConfig.template\n   * <a id='template'></a>\n   *   html template as a string or a function that returns\n   *   an html template as a string which should be used by the uiView directives. This property \n   *   takes precedence over templateUrl.\n   *   \n   *   If `template` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n   *     applying the current state\n   *\n   * <pre>template:\n   *   \"<h1>inline template definition</h1>\" +\n   *   \"<div ui-view></div>\"</pre>\n   * <pre>template: function(params) {\n   *       return \"<h1>generated template</h1>\"; }</pre>\n   * </div>\n   *\n   * @param {string|function=} stateConfig.templateUrl\n   * <a id='templateUrl'></a>\n   *\n   *   path or function that returns a path to an html\n   *   template that should be used by uiView.\n   *   \n   *   If `templateUrl` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n   *     applying the current state\n   *\n   * <pre>templateUrl: \"home.html\"</pre>\n   * <pre>templateUrl: function(params) {\n   *     return myTemplates[params.pageId]; }</pre>\n   *\n   * @param {function=} stateConfig.templateProvider\n   * <a id='templateProvider'></a>\n   *    Provider function that returns HTML content string.\n   * <pre> templateProvider:\n   *       function(MyTemplateService, params) {\n   *         return MyTemplateService.getTemplate(params.pageId);\n   *       }</pre>\n   *\n   * @param {string|function=} stateConfig.controller\n   * <a id='controller'></a>\n   *\n   *  Controller fn that should be associated with newly\n   *   related scope or the name of a registered controller if passed as a string.\n   *   Optionally, the ControllerAs may be declared here.\n   * <pre>controller: \"MyRegisteredController\"</pre>\n   * <pre>controller:\n   *     \"MyRegisteredController as fooCtrl\"}</pre>\n   * <pre>controller: function($scope, MyService) {\n   *     $scope.data = MyService.getData(); }</pre>\n   *\n   * @param {function=} stateConfig.controllerProvider\n   * <a id='controllerProvider'></a>\n   *\n   * Injectable provider function that returns the actual controller or string.\n   * <pre>controllerProvider:\n   *   function(MyResolveData) {\n   *     if (MyResolveData.foo)\n   *       return \"FooCtrl\"\n   *     else if (MyResolveData.bar)\n   *       return \"BarCtrl\";\n   *     else return function($scope) {\n   *       $scope.baz = \"Qux\";\n   *     }\n   *   }</pre>\n   *\n   * @param {string=} stateConfig.controllerAs\n   * <a id='controllerAs'></a>\n   * \n   * A controller alias name. If present the controller will be\n   *   published to scope under the controllerAs name.\n   * <pre>controllerAs: \"myCtrl\"</pre>\n   *\n   * @param {object=} stateConfig.resolve\n   * <a id='resolve'></a>\n   *\n   * An optional map&lt;string, function&gt; of dependencies which\n   *   should be injected into the controller. If any of these dependencies are promises, \n   *   the router will wait for them all to be resolved before the controller is instantiated.\n   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired\n   *   and the values of the resolved promises are injected into any controllers that reference them.\n   *   If any  of the promises are rejected the $stateChangeError event is fired.\n   *\n   *   The map object is:\n   *   \n   *   - key - {string}: name of dependency to be injected into controller\n   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n   *     it is injected and return value it treated as dependency. If result is a promise, it is \n   *     resolved before its value is injected into controller.\n   *\n   * <pre>resolve: {\n   *     myResolve1:\n   *       function($http, $stateParams) {\n   *         return $http.get(\"/api/foos/\"+stateParams.fooID);\n   *       }\n   *     }</pre>\n   *\n   * @param {string=} stateConfig.url\n   * <a id='url'></a>\n   *\n   *   A url fragment with optional parameters. When a state is navigated or\n   *   transitioned to, the `$stateParams` service will be populated with any \n   *   parameters that were passed.\n   *\n   * examples:\n   * <pre>url: \"/home\"\n   * url: \"/users/:userid\"\n   * url: \"/books/{bookid:[a-zA-Z_-]}\"\n   * url: \"/books/{categoryid:int}\"\n   * url: \"/books/{publishername:string}/{categoryid:int}\"\n   * url: \"/messages?before&after\"\n   * url: \"/messages?{before:date}&{after:date}\"</pre>\n   * url: \"/messages/:mailboxid?{before:date}&{after:date}\"\n   *\n   * @param {object=} stateConfig.views\n   * <a id='views'></a>\n   * an optional map&lt;string, object&gt; which defined multiple views, or targets views\n   * manually/explicitly.\n   *\n   * Examples:\n   *\n   * Targets three named `ui-view`s in the parent state's template\n   * <pre>views: {\n   *     header: {\n   *       controller: \"headerCtrl\",\n   *       templateUrl: \"header.html\"\n   *     }, body: {\n   *       controller: \"bodyCtrl\",\n   *       templateUrl: \"body.html\"\n   *     }, footer: {\n   *       controller: \"footCtrl\",\n   *       templateUrl: \"footer.html\"\n   *     }\n   *   }</pre>\n   *\n   * Targets named `ui-view=\"header\"` from grandparent state 'top''s template, and named `ui-view=\"body\" from parent state's template.\n   * <pre>views: {\n   *     'header@top': {\n   *       controller: \"msgHeaderCtrl\",\n   *       templateUrl: \"msgHeader.html\"\n   *     }, 'body': {\n   *       controller: \"messagesCtrl\",\n   *       templateUrl: \"messages.html\"\n   *     }\n   *   }</pre>\n   *\n   * @param {boolean=} [stateConfig.abstract=false]\n   * <a id='abstract'></a>\n   * An abstract state will never be directly activated,\n   *   but can provide inherited properties to its common children states.\n   * <pre>abstract: true</pre>\n   *\n   * @param {function=} stateConfig.onEnter\n   * <a id='onEnter'></a>\n   *\n   * Callback function for when a state is entered. Good way\n   *   to trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explictly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onEnter: function(MyService, $stateParams) {\n   *     MyService.foo($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {function=} stateConfig.onExit\n   * <a id='onExit'></a>\n   *\n   * Callback function for when a state is exited. Good way to\n   *   trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explictly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onExit: function(MyService, $stateParams) {\n   *     MyService.cleanup($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {boolean=} [stateConfig.reloadOnSearch=true]\n   * <a id='reloadOnSearch'></a>\n   *\n   * If `false`, will not retrigger the same state\n   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n   * <pre>reloadOnSearch: false</pre>\n   *\n   * @param {object=} stateConfig.data\n   * <a id='data'></a>\n   *\n   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is\n   *   prototypally inherited.  In other words, adding a data property to a state adds it to\n   *   the entire subtree via prototypal inheritance.\n   *\n   * <pre>data: {\n   *     requiredRole: 'foo'\n   * } </pre>\n   *\n   * @param {object=} stateConfig.params\n   * <a id='params'></a>\n   *\n   * A map which optionally configures parameters declared in the `url`, or\n   *   defines additional non-url parameters.  For each parameter being\n   *   configured, add a configuration object keyed to the name of the parameter.\n   *\n   *   Each parameter configuration object may contain the following properties:\n   *\n   *   - ** value ** - {object|function=}: specifies the default value for this\n   *     parameter.  This implicitly sets this parameter as optional.\n   *\n   *     When UI-Router routes to a state and no value is\n   *     specified for this parameter in the URL or transition, the\n   *     default value will be used instead.  If `value` is a function,\n   *     it will be injected and invoked, and the return value used.\n   *\n   *     *Note*: `undefined` is treated as \"no default value\" while `null`\n   *     is treated as \"the default value is `null`\".\n   *\n   *     *Shorthand*: If you only need to configure the default value of the\n   *     parameter, you may use a shorthand syntax.   In the **`params`**\n   *     map, instead mapping the param name to a full parameter configuration\n   *     object, simply set map it to the default parameter value, e.g.:\n   *\n   * <pre>// define a parameter's default value\n   * params: {\n   *     param1: { value: \"defaultValue\" }\n   * }\n   * // shorthand default values\n   * params: {\n   *     param1: \"defaultValue\",\n   *     param2: \"param2Default\"\n   * }</pre>\n   *\n   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be\n   *     treated as an array of values.  If you specified a Type, the value will be\n   *     treated as an array of the specified Type.  Note: query parameter values\n   *     default to a special `\"auto\"` mode.\n   *\n   *     For query parameters in `\"auto\"` mode, if multiple  values for a single parameter\n   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values\n   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if\n   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single\n   *     value (e.g.: `{ foo: '1' }`).\n   *\n   * <pre>params: {\n   *     param1: { array: true }\n   * }</pre>\n   *\n   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when\n   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the\n   *     configured default squash policy.\n   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})\n   *\n   *   There are three squash settings:\n   *\n   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL\n   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed\n   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.\n   *       This can allow for cleaner looking URLs.\n   *     - `\"<arbitrary string>\"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.\n   *\n   * <pre>params: {\n   *     param1: {\n   *       value: \"defaultId\",\n   *       squash: true\n   * } }\n   * // squash \"defaultValue\" to \"~\"\n   * params: {\n   *     param1: {\n   *       value: \"defaultValue\",\n   *       squash: \"~\"\n   * } }\n   * </pre>\n   *\n   *\n   * @example\n   * <pre>\n   * // Some state name examples\n   *\n   * // stateName can be a single top-level name (must be unique).\n   * $stateProvider.state(\"home\", {});\n   *\n   * // Or it can be a nested state name. This state is a child of the\n   * // above \"home\" state.\n   * $stateProvider.state(\"home.newest\", {});\n   *\n   * // Nest states as deeply as needed.\n   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n   *\n   * // state() returns $stateProvider, so you can chain state declarations.\n   * $stateProvider\n   *   .state(\"home\", {})\n   *   .state(\"about\", {})\n   *   .state(\"contacts\", {});\n   * </pre>\n   *\n   */\n  this.state = state;\n  function state(name, definition) {\n    /*jshint validthis: true */\n    if (isObject(name)) definition = name;\n    else definition.name = name;\n    registerState(definition);\n    return this;\n  }\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$state\n   *\n   * @requires $rootScope\n   * @requires $q\n   * @requires ui.router.state.$view\n   * @requires $injector\n   * @requires ui.router.util.$resolve\n   * @requires ui.router.state.$stateParams\n   * @requires ui.router.router.$urlRouter\n   *\n   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n   * you'd like to test against the current active state.\n   * @property {object} current A reference to the state's config object. However \n   * you passed it in. Useful for accessing custom data.\n   * @property {object} transition Currently pending transition. A promise that'll \n   * resolve or reject.\n   *\n   * @description\n   * `$state` service is responsible for representing states as well as transitioning\n   * between them. It also provides interfaces to ask for current state or even states\n   * you're coming from.\n   */\n  this.$get = $get;\n  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];\n  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {\n\n    var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n    var TransitionPrevented = $q.reject(new Error('transition prevented'));\n    var TransitionAborted = $q.reject(new Error('transition aborted'));\n    var TransitionFailed = $q.reject(new Error('transition failed'));\n\n    // Handles the case where a state which is the target of a transition is not found, and the user\n    // can optionally retry or defer the transition\n    function handleRedirect(redirect, state, params, options) {\n      /**\n       * @ngdoc event\n       * @name ui.router.state.$state#$stateNotFound\n       * @eventOf ui.router.state.$state\n       * @eventType broadcast on root scope\n       * @description\n       * Fired when a requested state **cannot be found** using the provided state name during transition.\n       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n       *\n       * @param {Object} event Event object.\n       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n       * @param {State} fromState Current state object.\n       * @param {Object} fromParams Current state params.\n       *\n       * @example\n       *\n       * <pre>\n       * // somewhere, assume lazy.state has not been defined\n       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n       *\n       * // somewhere else\n       * $scope.$on('$stateNotFound',\n       * function(event, unfoundState, fromState, fromParams){\n       *     console.log(unfoundState.to); // \"lazy.state\"\n       *     console.log(unfoundState.toParams); // {a:1, b:2}\n       *     console.log(unfoundState.options); // {inherit:false} + default options\n       * })\n       * </pre>\n       */\n      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\n      if (evt.defaultPrevented) {\n        $urlRouter.update();\n        return TransitionAborted;\n      }\n\n      if (!evt.retry) {\n        return null;\n      }\n\n      // Allow the handler to return a promise to defer state lookup retry\n      if (options.$retry) {\n        $urlRouter.update();\n        return TransitionFailed;\n      }\n      var retryTransition = $state.transition = $q.when(evt.retry);\n\n      retryTransition.then(function() {\n        if (retryTransition !== $state.transition) return TransitionSuperseded;\n        redirect.options.$retry = true;\n        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n      }, function() {\n        return TransitionAborted;\n      });\n      $urlRouter.update();\n\n      return retryTransition;\n    }\n\n    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\n    $state = {\n      params: {},\n      current: root.self,\n      $current: root,\n      transition: null\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#reload\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method that force reloads the current state. All resolves are re-resolved, events are not re-fired, \n     * and controllers reinstantiated (bug with controllers reinstantiating right now, fixing soon).\n     *\n     * @example\n     * <pre>\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n     *\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.reload = function reload() {\n      return $state.transitionTo($state.current, $stateParams, { reload: true, inherit: false, notify: true });\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#go\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Convenience method for transitioning to a new state. `$state.go` calls \n     * `$state.transitionTo` internally but automatically sets options to \n     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n     * This allows you to easily use an absolute or relative to path and specify \n     * only the parameters you'd like to update (while letting unspecified parameters \n     * inherit from the currently active ancestor states).\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * </pre>\n     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n     *\n     * @param {string} to Absolute state name or relative state path. Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to a parent state\n     * - `$state.go('^.sibling')` - will go to a sibling state\n     * - `$state.go('.child.grandchild')` - will go to grandchild state\n     *\n     * @param {object=} params A map of the parameters that will be sent to the state, \n     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n     * defined parameters. This allows, for example, going to a sibling state that shares parameters\n     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n     * will get you all current parameters, etc.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params \n     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n     *    use this when you want to force a reload when *everything* is the same, including search params.\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     *\n     * Possible success values:\n     *\n     * - $state.current\n     *\n     * <br/>Possible rejection values:\n     *\n     * - 'transition superseded' - when a newer transition has been started after this one\n     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n     *   when a `$stateNotFound` `event.retry` promise errors.\n     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n     * - *resolve error* - when an error has occurred with a `resolve`\n     *\n     */\n    $state.go = function go(to, params, options) {\n      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#transitionTo\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * </pre>\n     *\n     * @param {string} to State name.\n     * @param {object=} toParams A map of the parameters that will be sent to the state,\n     * will populate $stateParams.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params \n     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n     *    use this when you want to force a reload when *everything* is the same, including search params.\n     *\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.transitionTo = function transitionTo(to, toParams, options) {\n      toParams = toParams || {};\n      options = extend({\n        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n      }, options || {});\n\n      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n      var evt, toState = findState(to, options.relative);\n\n      if (!isDefined(toState)) {\n        var redirect = { to: to, toParams: toParams, options: options };\n        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\n        if (redirectResult) {\n          return redirectResult;\n        }\n\n        // Always retry once if the $stateNotFound was not prevented\n        // (handles either redirect changed or state lazy-definition)\n        to = redirect.to;\n        toParams = redirect.toParams;\n        options = redirect.options;\n        toState = findState(to, options.relative);\n\n        if (!isDefined(toState)) {\n          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n        }\n      }\n      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n      if (!toState.params.$$validates(toParams)) return TransitionFailed;\n\n      toParams = toState.params.$$values(toParams);\n      to = toState;\n\n      var toPath = to.path;\n\n      // Starting from the root of the path, keep all levels that haven't changed\n      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\n      if (!options.reload) {\n        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      }\n\n      // If we're going to the same state and all locals are kept, we've got nothing to do.\n      // But clear 'transition', as we still want to cancel any other pending transitions.\n      // TODO: We may not want to bump 'transition' if we're called from a location change\n      // that we've initiated ourselves, because we might accidentally abort a legitimate\n      // transition initiated from code?\n      if (shouldTriggerReload(to, from, locals, options)) {\n        if (to.self.reloadOnSearch !== false) $urlRouter.update();\n        $state.transition = null;\n        return $q.when($state.current);\n      }\n\n      // Filter parameters before we pass them to event handlers etc.\n      toParams = filterByKeys(to.params.$$keys(), toParams || {});\n\n      // Broadcast start event and cancel the transition if requested\n      if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeStart\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n         * to prevent the transition from happening and then the transition promise will be\n         * rejected with a `'transition prevented'` value.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         *\n         * @example\n         *\n         * <pre>\n         * $rootScope.$on('$stateChangeStart',\n         * function(event, toState, toParams, fromState, fromParams){\n         *     event.preventDefault();\n         *     // transitionTo() promise will be rejected with\n         *     // a 'transition prevented' error\n         * })\n         * </pre>\n         */\n        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams).defaultPrevented) {\n          $urlRouter.update();\n          return TransitionPrevented;\n        }\n      }\n\n      // Resolve locals for the remaining states, but don't update any global state just\n      // yet -- if anything fails to resolve the current state needs to remain untouched.\n      // We also set up an inheritance chain for the locals here. This allows the view directive\n      // to quickly look up the correct definition for each view in the current state. Even\n      // though we create the locals object itself outside resolveState(), it is initially\n      // empty and gets filled asynchronously. We need to keep track of the promise for the\n      // (fully resolved) current locals, and pass this down the chain.\n      var resolved = $q.when(locals);\n\n      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n        locals = toLocals[l] = inherit(locals);\n        resolved = resolveState(state, toParams, state === to, resolved, locals, options);\n      }\n\n      // Once everything is resolved, we are ready to perform the actual transition\n      // and return a promise for the new state. We also keep track of what the\n      // current promise is, so that we can detect overlapping transitions and\n      // keep only the outcome of the last transition.\n      var transition = $state.transition = resolved.then(function () {\n        var l, entering, exiting;\n\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Exit 'from' states not kept\n        for (l = fromPath.length - 1; l >= keep; l--) {\n          exiting = fromPath[l];\n          if (exiting.self.onExit) {\n            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n          }\n          exiting.locals = null;\n        }\n\n        // Enter 'to' states not kept\n        for (l = keep; l < toPath.length; l++) {\n          entering = toPath[l];\n          entering.locals = toLocals[l];\n          if (entering.self.onEnter) {\n            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n          }\n        }\n\n        // Run it again, to catch any transitions in callbacks\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Update globals in $state\n        $state.$current = to;\n        $state.current = to.self;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        $state.transition = null;\n\n        if (options.location && to.navigable) {\n          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n        }\n\n        if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeSuccess\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired once the state transition is **complete**.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         */\n          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n        }\n        $urlRouter.update(true);\n\n        return $state.current;\n      }, function (error) {\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        $state.transition = null;\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeError\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when an **error occurs** during transition. It's important to note that if you\n         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n         * they will not throw traditionally. You must listen for this $stateChangeError event to\n         * catch **ALL** errors.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         * @param {Error} error The resolve error object.\n         */\n        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\n        if (!evt.defaultPrevented) {\n            $urlRouter.update();\n        }\n\n        return $q.reject(error);\n      });\n\n      return transition;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#is\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n     * but only checks for the full state name. If params is supplied then it will be\n     * tested for strict equality against the current active params object, so all params\n     * must match with none missing and no extras.\n     *\n     * @example\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\n     * to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     * test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it is the state.\n     */\n    $state.is = function is(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) { return undefined; }\n      if ($state.$current !== state) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#includes\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * @example\n     * Partial and relative names\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     *\n     * // Using relative names (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n     * </pre>\n     *\n     * Basic globbing patterns\n     * <pre>\n     * $state.$current.name = 'contacts.details.item.url';\n     *\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * </pre>\n     *\n     * @param {string} stateOrName A partial name, relative name, or glob pattern\n     * to be searched for within the current state name.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\n     * that you'd like to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\n     * .includes will test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it does include the state\n     */\n    $state.includes = function includes(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      if (isString(stateOrName) && isGlob(stateOrName)) {\n        if (!doesStateMatchGlob(stateOrName)) {\n          return false;\n        }\n        stateOrName = $state.$current.name;\n      }\n\n      var state = findState(stateOrName, options.relative);\n      if (!isDefined(state)) { return undefined; }\n      if (!isDefined($state.$current.includes[state.name])) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;\n    };\n\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#href\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A url generation method that returns the compiled url for the given state populated with the given params.\n     *\n     * @example\n     * <pre>\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n     * @param {object=} params An object of parameter values to fill the state's required parameters.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n     *    ancestor with a valid url).\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     * \n     * @returns {string} compiled state url\n     */\n    $state.href = function href(stateOrName, params, options) {\n      options = extend({\n        lossy:    true,\n        inherit:  true,\n        absolute: false,\n        relative: $state.$current\n      }, options || {});\n\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) return null;\n      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n      \n      var nav = (state && options.lossy) ? state.navigable : state;\n\n      if (!nav || nav.url === undefined || nav.url === null) {\n        return null;\n      }\n      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys(), params || {}), {\n        absolute: options.absolute\n      });\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#get\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Returns the state configuration object for any specific state or all states.\n     *\n     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for\n     * the requested state. If not provided, returns an array of ALL state configs.\n     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.\n     * @returns {Object|Array} State configuration object or array of all objects.\n     */\n    $state.get = function (stateOrName, context) {\n      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });\n      var state = findState(stateOrName, context || $state.$current);\n      return (state && state.self) ? state.self : null;\n    };\n\n    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {\n      // Make a restricted $stateParams with only the parameters that apply to this state if\n      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n      // we also need $stateParams to be available for any $injector calls we make during the\n      // dependency resolution process.\n      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);\n      var locals = { $stateParams: $stateParams };\n\n      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n      // We're also including $stateParams in this; that way the parameters are restricted\n      // to the set that should be visible to the state, and are independent of when we update\n      // the global $state and $stateParams values.\n      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n      var promises = [dst.resolve.then(function (globals) {\n        dst.globals = globals;\n      })];\n      if (inherited) promises.push(inherited);\n\n      // Resolve template and dependencies for all views.\n      forEach(state.views, function (view, name) {\n        var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n        injectables.$template = [ function () {\n          return $view.load(name, { view: view, locals: locals, params: $stateParams, notify: options.notify }) || '';\n        }];\n\n        promises.push($resolve.resolve(injectables, locals, dst.resolve, state).then(function (result) {\n          // References to the controller (only instantiated at link time)\n          if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n            var injectLocals = angular.extend({}, injectables, locals);\n            result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n          } else {\n            result.$$controller = view.controller;\n          }\n          // Provide access to the state itself for internal use\n          result.$$state = state;\n          result.$$controllerAs = view.controllerAs;\n          dst[name] = result;\n        }));\n      });\n\n      // Wait for all the promises and then return the activation object\n      return $q.all(promises).then(function (values) {\n        return dst;\n      });\n    }\n\n    return $state;\n  }\n\n  function shouldTriggerReload(to, from, locals, options) {\n    if (to === from && ((locals === from.locals && !options.reload) || (to.self.reloadOnSearch === false))) {\n      return true;\n    }\n  }\n}\n\nangular.module('ui.router.state')\n  .value('$stateParams', {})\n  .provider('$state', $StateProvider);\n"]}