{"version":3,"sources":["/Users/derwilliams/workspace/me/projects/phymoo/www/lib/angular-ui-router/src/urlMatcherFactory.js"],"names":[],"mappings":"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","file":"urlMatcherFactory-compiled.js","sourcesContent":["var $$UMFP; // reference to $UrlMatcherFactoryProvider\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:UrlMatcher\n *\n * @description\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n * \n * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n * syntax, which optionally allows a regular expression for the parameter to be specified:\n *\n * * `':'` name - colon placeholder\n * * `'*'` name - catch-all placeholder\n * * `'{' name '}'` - curly placeholder\n * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\n *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters). For colon \n * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n * number of characters other than '/'. For catch-all placeholders the path parameter matches\n * any number of characters.\n * \n * Examples:\n * \n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n * @param {string} pattern  The pattern to compile into a matcher.\n * @param {Object} config  A configuration object hash:\n * @param {Object=} parentMatcher Used to concatenate the pattern/config onto\n *   an existing UrlMatcher\n *\n * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n *\n * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n *   non-null) will start with this prefix.\n *\n * @property {string} source  The pattern that was passed into the constructor\n *\n * @property {string} sourcePath  The path portion of the source property\n *\n * @property {string} sourceSearch  The search portion of the source property\n *\n * @property {string} regex  The constructed regex that will be used to match against the url when \n *   it is time to determine which url will match.\n *\n * @returns {Object}  New `UrlMatcher` object\n */\nfunction UrlMatcher(pattern, config, parentMatcher) {\n  config = extend({ params: {} }, isObject(config) ? config : {});\n\n  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n  //   '*' name\n  //   ':' name\n  //   '{' name '}'\n  //   '{' name ':' regexp '}'\n  // The regular expression is somewhat complicated due to the need to allow curly braces\n  // inside the regular expression. The placeholder regexp breaks down as follows:\n  //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n  //    \\{([\\w\\[\\]]+)(?:\\:( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n  //    [^{}\\\\]+                       - anything other than curly braces or backslash\n  //    \\\\.                            - a backslash escape\n  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n  var placeholder       = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      searchPlaceholder = /([:]?)([\\w\\[\\]-]+)|\\{([\\w\\[\\]-]+)(?:\\:((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      compiled = '^', last = 0, m,\n      segments = this.segments = [],\n      parentParams = parentMatcher ? parentMatcher.params : {},\n      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),\n      paramNames = [];\n\n  function addParameter(id, type, config, location) {\n    paramNames.push(id);\n    if (parentParams[id]) return parentParams[id];\n    if (!/^\\w+(-+\\w+)*(?:\\[\\])?$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    params[id] = new $$UMFP.Param(id, type, config, location);\n    return params[id];\n  }\n\n  function quoteRegExp(string, pattern, squash) {\n    var surroundPattern = ['',''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!pattern) return result;\n    switch(squash) {\n      case false: surroundPattern = ['(', ')'];   break;\n      case true:  surroundPattern = ['?(', ')?']; break;\n      default:    surroundPattern = ['(' + squash + \"|\", ')?'];  break;\n    }\n    return result + surroundPattern[0] + pattern + surroundPattern[1];\n  }\n\n  this.source = pattern;\n\n  // Split into static segments separated by path parameter placeholders.\n  // The number of segments is always 1 more than the number of parameters.\n  function matchDetails(m, isSearch) {\n    var id, regexp, segment, type, cfg, arrayMode;\n    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n    cfg         = config.params[id];\n    segment     = pattern.substring(last, m.index);\n    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);\n    type        = $$UMFP.type(regexp || \"string\") || inherit($$UMFP.type(\"string\"), { pattern: new RegExp(regexp) });\n    return {\n      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg\n    };\n  }\n\n  var p, param, segment;\n  while ((m = placeholder.exec(pattern))) {\n    p = matchDetails(m, false);\n    if (p.segment.indexOf('?') >= 0) break; // we're into the search part\n\n    param = addParameter(p.id, p.type, p.cfg, \"path\");\n    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash);\n    segments.push(p.segment);\n    last = placeholder.lastIndex;\n  }\n  segment = pattern.substring(last);\n\n  // Find any search parameter names and remove them from the last segment\n  var i = segment.indexOf('?');\n\n  if (i >= 0) {\n    var search = this.sourceSearch = segment.substring(i);\n    segment = segment.substring(0, i);\n    this.sourcePath = pattern.substring(0, last + i);\n\n    if (search.length > 0) {\n      last = 0;\n      while ((m = searchPlaceholder.exec(search))) {\n        p = matchDetails(m, true);\n        param = addParameter(p.id, p.type, p.cfg, \"search\");\n        last = placeholder.lastIndex;\n        // check if ?&\n      }\n    }\n  } else {\n    this.sourcePath = pattern;\n    this.sourceSearch = '';\n  }\n\n  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n  segments.push(segment);\n\n  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n  this.prefix = segments[0];\n  this.$$paramNames = paramNames;\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#concat\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns a new matcher for a pattern constructed by appending the path part and adding the\n * search parameters of the specified pattern to this pattern. The current pattern is not\n * modified. This can be understood as creating a pattern for URLs that are relative to (or\n * suffixes of) the current pattern.\n *\n * @example\n * The following two matchers are equivalent:\n * <pre>\n * new UrlMatcher('/user/{id}?q').concat('/details?date');\n * new UrlMatcher('/user/{id}/details?q&date');\n * </pre>\n *\n * @param {string} pattern  The pattern to append.\n * @param {Object} config  An object hash of the configuration for the matcher.\n * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n */\nUrlMatcher.prototype.concat = function (pattern, config) {\n  // Because order of search parameters is irrelevant, we can add our own search\n  // parameters to the end of the new pattern. Parse the new pattern by itself\n  // and then join the bits together, but it's much easier to do this on a string level.\n  var defaultConfig = {\n    caseInsensitive: $$UMFP.caseInsensitive(),\n    strict: $$UMFP.strictMode(),\n    squash: $$UMFP.defaultSquashPolicy()\n  };\n  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);\n};\n\nUrlMatcher.prototype.toString = function () {\n  return this.source;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#exec\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Tests the specified path against this matcher, and returns an object containing the captured\n * parameter values, or null if the path does not match. The returned object contains the values\n * of any search parameters that are mentioned in the pattern, but their value may be null if\n * they are not present in `searchParams`. This means that search parameters are always treated\n * as optional.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n *   x: '1', q: 'hello'\n * });\n * // returns { id: 'bob', q: 'hello', r: null }\n * </pre>\n *\n * @param {string} path  The URL path to match, e.g. `$location.path()`.\n * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n * @returns {Object}  The captured parameter values.\n */\nUrlMatcher.prototype.exec = function (path, searchParams) {\n  var m = this.regexp.exec(path);\n  if (!m) return null;\n  searchParams = searchParams || {};\n\n  var paramNames = this.parameters(), nTotal = paramNames.length,\n    nPath = this.segments.length - 1,\n    values = {}, i, j, cfg, paramName;\n\n  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\n  function decodePathArray(string) {\n    function reverseString(str) { return str.split(\"\").reverse().join(\"\"); }\n    function unquoteDashes(str) { return str.replace(/\\\\-/, \"-\"); }\n\n    var split = reverseString(string).split(/-(?!\\\\)/);\n    var allReversed = map(split, reverseString);\n    return map(allReversed, unquoteDashes).reverse();\n  }\n\n  for (i = 0; i < nPath; i++) {\n    paramName = paramNames[i];\n    var param = this.params[paramName];\n    var paramVal = m[i+1];\n    // if the param value matches a pre-replace pair, replace the value before decoding.\n    for (j = 0; j < param.replace; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n  for (/**/; i < nTotal; i++) {\n    paramName = paramNames[i];\n    values[paramName] = this.params[paramName].value(searchParams[paramName]);\n  }\n\n  return values;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#parameters\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns the names of all path and search parameters of this pattern in an unspecified order.\n * \n * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n *    pattern has no parameters, an empty array is returned.\n */\nUrlMatcher.prototype.parameters = function (param) {\n  if (!isDefined(param)) return this.$$paramNames;\n  return this.params[param] || null;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#validate\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Checks an object hash of parameters to validate their correctness according to the parameter\n * types of this `UrlMatcher`.\n *\n * @param {Object} params The object hash of parameters to validate.\n * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n */\nUrlMatcher.prototype.validates = function (params) {\n  return this.params.$$validates(params);\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#format\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Creates a URL that matches this pattern by substituting the specified values\n * for the path and search parameters. Null values for path parameters are\n * treated as empty strings.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n * // returns '/user/bob?q=yes'\n * </pre>\n *\n * @param {Object} values  the values to substitute for the parameters in this pattern.\n * @returns {string}  the formatted URL (path and optionally search part).\n */\nUrlMatcher.prototype.format = function (values) {\n  values = values || {};\n  var segments = this.segments, params = this.parameters(), paramset = this.params;\n  if (!this.validates(values)) return null;\n\n  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];\n\n  function encodeDashes(str) { // Replace dashes with encoded \"\\-\"\n    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });\n  }\n\n  for (i = 0; i < nTotal; i++) {\n    var isPathParam = i < nPath;\n    var name = params[i], param = paramset[name], value = param.value(values[name]);\n    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);\n    var squash = isDefaultValue ? param.squash : false;\n    var encoded = param.type.encode(value);\n\n    if (isPathParam) {\n      var nextSegment = segments[i + 1];\n      if (squash === false) {\n        if (encoded != null) {\n          if (isArray(encoded)) {\n            result += map(encoded, encodeDashes).join(\"-\");\n          } else {\n            result += encodeURIComponent(encoded);\n          }\n        }\n        result += nextSegment;\n      } else if (squash === true) {\n        var capture = result.match(/\\/$/) ? /\\/?(.*)/ : /(.*)/;\n        result += nextSegment.match(capture)[1];\n      } else if (isString(squash)) {\n        result += squash + nextSegment;\n      }\n    } else {\n      if (encoded == null || (isDefaultValue && squash !== false)) continue;\n      if (!isArray(encoded)) encoded = [ encoded ];\n      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');\n      result += (search ? '&' : '?') + (name + '=' + encoded);\n      search = true;\n    }\n  }\n\n  return result;\n};\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:Type\n *\n * @description\n * Implements an interface to define custom parameter types that can be decoded from and encoded to\n * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n * objects when matching or formatting URLs, or comparing or validating parameter values.\n *\n * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n * information on registering custom types.\n *\n * @param {Object} config  A configuration object which contains the custom type definition.  The object's\n *        properties will override the default methods and/or pattern in `Type`'s public interface.\n * @example\n * <pre>\n * {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n * </pre>\n *\n * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n *           coming from a substring of a URL.\n *\n * @returns {Object}  Returns a new `Type` object.\n */\nfunction Type(config) {\n  extend(this, config);\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#is\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Detects whether a value is of a particular type. Accepts a native (decoded) value\n * and determines whether it matches the current `Type` object.\n *\n * @param {*} val  The value to check.\n * @param {string} key  Optional. If the type check is happening in the context of a specific\n *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n */\nType.prototype.is = function(val, key) {\n  return true;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#encode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n * only needs to be a representation of `val` that has been coerced to a string.\n *\n * @param {*} val  The value to encode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n */\nType.prototype.encode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#decode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Converts a parameter value (from URL string or transition param) to a custom/native value.\n *\n * @param {string} val  The URL parameter value to decode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {*}  Returns a custom representation of the URL parameter value.\n */\nType.prototype.decode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#equals\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Determines whether two decoded values are equivalent.\n *\n * @param {*} a  A value to compare against.\n * @param {*} b  A value to compare against.\n * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n */\nType.prototype.equals = function(a, b) {\n  return a == b;\n};\n\nType.prototype.$subPattern = function() {\n  var sub = this.pattern.toString();\n  return sub.substr(1, sub.length - 2);\n};\n\nType.prototype.pattern = /.*/;\n\nType.prototype.toString = function() { return \"{Type:\" + this.name + \"}\"; };\n\n/*\n * Wraps an existing custom Type as an array of Type, depending on 'mode'.\n * e.g.:\n * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n * - url: \"/path?queryParam=1&queryParam=2\n * - $stateParams.queryParam will be [1, 2]\n * if `mode` is \"auto\", then\n * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n */\nType.prototype.$asArray = function(mode, isSearch) {\n  if (!mode) return this;\n  if (mode === \"auto\" && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n  return new ArrayType(this, mode);\n\n  function ArrayType(type, mode) {\n    function bindTo(type, callbackName) {\n      return function() {\n        return type[callbackName].apply(type, arguments);\n      };\n    }\n\n    // Wrap non-array value as array\n    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }\n    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n    function arrayUnwrap(val) {\n      switch(val.length) {\n        case 0: return undefined;\n        case 1: return mode === \"auto\" ? val[0] : val;\n        default: return val;\n      }\n    }\n    function falsey(val) { return !val; }\n\n    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n    function arrayHandler(callback, allTruthyMode) {\n      return function handleArray(val) {\n        val = arrayWrap(val);\n        var result = map(val, callback);\n        if (allTruthyMode === true)\n          return filter(result, falsey).length === 0;\n        return arrayUnwrap(result);\n      };\n    }\n\n    // Wraps type (.equals) functions to operate on each value of an array\n    function arrayEqualsHandler(callback) {\n      return function handleArray(val1, val2) {\n        var left = arrayWrap(val1), right = arrayWrap(val2);\n        if (left.length !== right.length) return false;\n        for (var i = 0; i < left.length; i++) {\n          if (!callback(left[i], right[i])) return false;\n        }\n        return true;\n      };\n    }\n\n    this.encode = arrayHandler(bindTo(type, 'encode'));\n    this.decode = arrayHandler(bindTo(type, 'decode'));\n    this.is     = arrayHandler(bindTo(type, 'is'), true);\n    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));\n    this.pattern = type.pattern;\n    this.$arrayMode = mode;\n  }\n};\n\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$urlMatcherFactory\n *\n * @description\n * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n * is also available to providers under the name `$urlMatcherFactoryProvider`.\n */\nfunction $UrlMatcherFactory() {\n  $$UMFP = this;\n\n  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;\n\n  function valToString(val) { return val != null ? val.toString().replace(/\\//g, \"%2F\") : val; }\n  function valFromString(val) { return val != null ? val.toString().replace(/%2F/g, \"/\") : val; }\n//  TODO: in 1.0, make string .is() return false if value is undefined by default.\n//  function regexpMatches(val) { /*jshint validthis:true */ return isDefined(val) && this.pattern.test(val); }\n  function regexpMatches(val) { /*jshint validthis:true */ return this.pattern.test(val); }\n\n  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {\n    string: {\n      encode: valToString,\n      decode: valFromString,\n      is: regexpMatches,\n      pattern: /[^/]*/\n    },\n    int: {\n      encode: valToString,\n      decode: function(val) { return parseInt(val, 10); },\n      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },\n      pattern: /\\d+/\n    },\n    bool: {\n      encode: function(val) { return val ? 1 : 0; },\n      decode: function(val) { return parseInt(val, 10) !== 0; },\n      is: function(val) { return val === true || val === false; },\n      pattern: /0|1/\n    },\n    date: {\n      encode: function (val) {\n        if (!this.is(val))\n          return undefined;\n        return [ val.getFullYear(),\n          ('0' + (val.getMonth() + 1)).slice(-2),\n          ('0' + val.getDate()).slice(-2)\n        ].join(\"-\");\n      },\n      decode: function (val) {\n        if (this.is(val)) return val;\n        var match = this.capture.exec(val);\n        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n      },\n      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },\n      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },\n      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n    },\n    json: {\n      encode: angular.toJson,\n      decode: angular.fromJson,\n      is: angular.isObject,\n      equals: angular.equals,\n      pattern: /[^/]*/\n    },\n    any: { // does not encode/decode\n      encode: angular.identity,\n      decode: angular.identity,\n      is: angular.identity,\n      equals: angular.equals,\n      pattern: /.*/\n    }\n  };\n\n  function getDefaultConfig() {\n    return {\n      strict: isStrictMode,\n      caseInsensitive: isCaseInsensitive\n    };\n  }\n\n  function isInjectable(value) {\n    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n  }\n\n  /**\n   * [Internal] Get the default value of a parameter, which may be an injectable function.\n   */\n  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n    if (!isInjectable(config.value)) return config.value;\n    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n    return injector.invoke(config.value);\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n   *\n   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n   * @returns {boolean} the current value of caseInsensitive\n   */\n  this.caseInsensitive = function(value) {\n    if (isDefined(value))\n      isCaseInsensitive = value;\n    return isCaseInsensitive;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#strictMode\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n   *\n   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.\n   * @returns {boolean} the current value of strictMode\n   */\n  this.strictMode = function(value) {\n    if (isDefined(value))\n      isStrictMode = value;\n    return isStrictMode;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Sets the default behavior when generating or matching URLs with default parameter values.\n   *\n   * @param {string} value A string that defines the default parameter URL squashing behavior.\n   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n   *             parameter is surrounded by slashes, squash (remove) one slash from the URL\n   *    any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n   *             the parameter value from the URL and replace it with this string.\n   */\n  this.defaultSquashPolicy = function(value) {\n    if (!isDefined(value)) return defaultSquashPolicy;\n    if (value !== true && value !== false && !isString(value))\n      throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n    defaultSquashPolicy = value;\n    return value;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#compile\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n   *\n   * @param {string} pattern  The URL pattern.\n   * @param {Object} config  The config object hash.\n   * @returns {UrlMatcher}  The UrlMatcher.\n   */\n  this.compile = function (pattern, config) {\n    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#isMatcher\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n   *\n   * @param {Object} object  The object to perform the type check against.\n   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n   *          implementing all the same methods.\n   */\n  this.isMatcher = function (o) {\n    if (!isObject(o)) return false;\n    var result = true;\n\n    forEach(UrlMatcher.prototype, function(val, name) {\n      if (isFunction(val)) {\n        result = result && (isDefined(o[name]) && isFunction(o[name]));\n      }\n    });\n    return result;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#type\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n   * generate URLs with typed parameters.\n   *\n   * @param {string} name  The type name.\n   * @param {Object|Function} definition   The type definition. See\n   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   * @param {Object|Function} definitionFn (optional) A function that is injected before the app\n   *        runtime starts.  The result of this function is merged into the existing `definition`.\n   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   *\n   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n   *\n   * @example\n   * This is a simple example of a custom type that encodes and decodes items from an\n   * array, using the array index as the URL-encoded value:\n   *\n   * <pre>\n   * var list = ['John', 'Paul', 'George', 'Ringo'];\n   *\n   * $urlMatcherFactoryProvider.type('listItem', {\n   *   encode: function(item) {\n   *     // Represent the list item in the URL using its corresponding index\n   *     return list.indexOf(item);\n   *   },\n   *   decode: function(item) {\n   *     // Look up the list item by index\n   *     return list[parseInt(item, 10)];\n   *   },\n   *   is: function(item) {\n   *     // Ensure the item is valid by checking to see that it appears\n   *     // in the list\n   *     return list.indexOf(item) > -1;\n   *   }\n   * });\n   *\n   * $stateProvider.state('list', {\n   *   url: \"/list/{item:listItem}\",\n   *   controller: function($scope, $stateParams) {\n   *     console.log($stateParams.item);\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n   * $state.go('list', { item: \"Ringo\" });\n   * </pre>\n   *\n   * This is a more complex example of a type that relies on dependency injection to\n   * interact with services, and uses the parameter name from the URL to infer how to\n   * handle encoding and decoding parameter values:\n   *\n   * <pre>\n   * // Defines a custom type that gets a value from a service,\n   * // where each service gets different types of values from\n   * // a backend API:\n   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {\n   *\n   *   // Matches up services to URL parameter names\n   *   var services = {\n   *     user: Users,\n   *     post: Posts\n   *   };\n   *\n   *   return {\n   *     encode: function(object) {\n   *       // Represent the object in the URL using its unique ID\n   *       return object.id;\n   *     },\n   *     decode: function(value, key) {\n   *       // Look up the object by ID, using the parameter\n   *       // name (key) to call the correct service\n   *       return services[key].findById(value);\n   *     },\n   *     is: function(object, key) {\n   *       // Check that object is a valid dbObject\n   *       return angular.isObject(object) && object.id && services[key];\n   *     }\n   *     equals: function(a, b) {\n   *       // Check the equality of decoded objects by comparing\n   *       // their unique IDs\n   *       return a.id === b.id;\n   *     }\n   *   };\n   * });\n   *\n   * // In a config() block, you can then attach URLs with\n   * // type-annotated parameters:\n   * $stateProvider.state('users', {\n   *   url: \"/users\",\n   *   // ...\n   * }).state('users.item', {\n   *   url: \"/{user:dbObject}\",\n   *   controller: function($scope, $stateParams) {\n   *     // $stateParams.user will now be an object returned from\n   *     // the Users service\n   *   },\n   *   // ...\n   * });\n   * </pre>\n   */\n  this.type = function (name, definition, definitionFn) {\n    if (!isDefined(definition)) return $types[name];\n    if ($types.hasOwnProperty(name)) throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\n    $types[name] = new Type(extend({ name: name }, definition));\n    if (definitionFn) {\n      typeQueue.push({ name: name, def: definitionFn });\n      if (!enqueue) flushTypeQueue();\n    }\n    return this;\n  };\n\n  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s\n  function flushTypeQueue() {\n    while(typeQueue.length) {\n      var type = typeQueue.shift();\n      if (type.pattern) throw new Error(\"You cannot override a type's .pattern at runtime.\");\n      angular.extend($types[type.name], injector.invoke(type.def));\n    }\n  }\n\n  // Register default types. Store them in the prototype of $types.\n  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });\n  $types = inherit($types, {});\n\n  /* No need to document $get, since it returns this */\n  this.$get = ['$injector', function ($injector) {\n    injector = $injector;\n    enqueue = false;\n    flushTypeQueue();\n\n    forEach(defaultTypes, function(type, name) {\n      if (!$types[name]) $types[name] = new Type(type);\n    });\n    return this;\n  }];\n\n  this.Param = function Param(id, type, config, location) {\n    var self = this;\n    config = unwrapShorthand(config);\n    type = getType(config, type, location);\n    var arrayMode = getArrayMode();\n    type = arrayMode ? type.$asArray(arrayMode, location === \"search\") : type;\n    if (type.name === \"string\" && !arrayMode && location === \"path\" && config.value === undefined)\n      config.value = \"\"; // for 0.2.x; in 0.3.0+ do not automatically default to \"\"\n    var isOptional = config.value !== undefined;\n    var squash = getSquashPolicy(config, isOptional);\n    var replace = getReplace(config, arrayMode, isOptional, squash);\n\n    function unwrapShorthand(config) {\n      var keys = isObject(config) ? objectKeys(config) : [];\n      var isShorthand = indexOf(keys, \"value\") === -1 && indexOf(keys, \"type\") === -1 &&\n                        indexOf(keys, \"squash\") === -1 && indexOf(keys, \"array\") === -1;\n      if (isShorthand) config = { value: config };\n      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };\n      return config;\n    }\n\n    function getType(config, urlType, location) {\n      if (config.type && urlType) throw new Error(\"Param '\"+id+\"' has two type configurations.\");\n      if (urlType) return urlType;\n      if (!config.type) return (location === \"config\" ? $types.any : $types.string);\n      return config.type instanceof Type ? config.type : new Type(config.type);\n    }\n\n    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n    function getArrayMode() {\n      var arrayDefaults = { array: (location === \"search\" ? \"auto\" : false) };\n      var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n    }\n\n    /**\n     * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n     */\n    function getSquashPolicy(config, isOptional) {\n      var squash = config.squash;\n      if (!isOptional || squash === false) return false;\n      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\n      if (squash === true || isString(squash)) return squash;\n      throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n    }\n\n    function getReplace(config, arrayMode, isOptional, squash) {\n      var replace, configuredKeys, defaultPolicy = [\n        { from: \"\",   to: (isOptional || arrayMode ? undefined : \"\") },\n        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n      ];\n      replace = isArray(config.replace) ? config.replace : [];\n      if (isString(squash))\n        replace.push({ from: squash, to: undefined });\n      configuredKeys = map(replace, function(item) { return item.from; } );\n      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);\n    }\n\n    /**\n     * [Internal] Get the default value of a parameter, which may be an injectable function.\n     */\n    function $$getDefaultValue() {\n      if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n      return injector.invoke(config.$$fn);\n    }\n\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    function $value(value) {\n      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }\n      function $replace(value) {\n        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });\n        return replacement.length ? replacement[0] : value;\n      }\n      value = $replace(value);\n      return isDefined(value) ? self.type.decode(value) : $$getDefaultValue();\n    }\n\n    function toString() { return \"{Param:\" + id + \" \" + type + \" squash: '\" + squash + \"' optional: \" + isOptional + \"}\"; }\n\n    extend(this, {\n      id: id,\n      type: type,\n      location: location,\n      array: arrayMode,\n      squash: squash,\n      replace: replace,\n      isOptional: isOptional,\n      value: $value,\n      dynamic: undefined,\n      config: config,\n      toString: toString\n    });\n  };\n\n  function ParamSet(params) {\n    extend(this, params || {});\n  }\n\n  ParamSet.prototype = {\n    $$new: function() {\n      return inherit(this, extend(new ParamSet(), { $$parent: this}));\n    },\n    $$keys: function () {\n      var keys = [], chain = [], parent = this,\n        ignore = objectKeys(ParamSet.prototype);\n      while (parent) { chain.push(parent); parent = parent.$$parent; }\n      chain.reverse();\n      forEach(chain, function(paramset) {\n        forEach(objectKeys(paramset), function(key) {\n            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);\n        });\n      });\n      return keys;\n    },\n    $$values: function(paramValues) {\n      var values = {}, self = this;\n      forEach(self.$$keys(), function(key) {\n        values[key] = self[key].value(paramValues && paramValues[key]);\n      });\n      return values;\n    },\n    $$equals: function(paramValues1, paramValues2) {\n      var equal = true, self = this;\n      forEach(self.$$keys(), function(key) {\n        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];\n        if (!self[key].type.equals(left, right)) equal = false;\n      });\n      return equal;\n    },\n    $$validates: function $$validate(paramValues) {\n      var result = true, isOptional, val, param, self = this;\n\n      forEach(this.$$keys(), function(key) {\n        param = self[key];\n        val = paramValues[key];\n        isOptional = !val && param.isOptional;\n        result = result && (isOptional || !!param.type.is(val));\n      });\n      return result;\n    },\n    $$parent: undefined\n  };\n\n  this.ParamSet = ParamSet;\n}\n\n// Register as a provider so it's available to other providers\nangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\nangular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);\n"]}